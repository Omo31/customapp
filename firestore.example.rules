rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // --- Helper Functions ---
    // NOTE: All functions are declared at the top level, inside the first match block.

    function getUserData(userId) {
      let uid = userId ? userId : request.auth.uid;
      return get(/databases/$(database)/documents/users/$(uid)).data;
    }

    function isNotDisabled() {
      // If the `disabled` field does not exist or is not true, the user is considered active.
      return getUserData(request.auth.uid).disabled != true;
    }

    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId && isNotDisabled();
    }

    // Checks if the requesting user has a specific role and is not disabled.
    // Includes a superadmin override for a specific email address.
    function hasRole(role) {
      // The superadmin has all roles implicitly.
      if (request.auth.token.email == 'oluwagbengwumi@gmail.com') {
        return true;
      }
      // For regular users, they must be authenticated, have a user profile,
      // have the specific role in their `roles` array, and not be disabled.
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             role in getUserData(request.auth.uid).roles &&
             isNotDisabled();
    }
    
    // Checks if the user has at least one role, making them an admin.
    function isAdmin() {
      if (request.auth.token.email == 'oluwagbengwumi@gmail.com') {
        return true;
      }
      return request.auth != null && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData(request.auth.uid).roles.size() > 0 &&
             isNotDisabled();
    }
    
    // Shortcut to check if the current user is the owner of a quote document.
    function isQuoteOwner(quote) {
      return isOwner(quote.userId);
    }
    
    // Checks if a document's status is being changed to a specific new value.
    function isChangingStatusTo(newStatus) {
      return request.resource.data.status == newStatus && resource.data.status != newStatus;
    }

    // --- Collection Rules ---

    // Rules for the `users` collection.
    match /users/{userId} {
      // Admins can read any profile; users can read their own if not disabled.
      allow read: if hasRole('users') || isOwner(userId);
      // Admins can update any profile; users can update their own if not disabled.
      allow update: if hasRole('users') || isOwner(userId);
      // A user can only create their own document during signup.
      allow create: if request.auth.uid == userId;
      // Only admins can delete users.
      allow delete: if hasRole('users');
      // Admins with the 'users' role can get a list of all users.
      allow list: if hasRole('users');

      // Rules for the `notifications` sub-collection within each user document.
      match /notifications/{notificationId} {
        // A user can fully manage their own notifications.
        allow read, write, create, list: if isOwner(userId);
      }
    }

    // Rules for the `quotes` collection.
    match /quotes/{quoteId} {
      // Users can read their own quotes; admins with 'quotes' role can read any quote.
      allow read: if isQuoteOwner(resource.data) || hasRole('quotes');
      // Admins can update quotes; owners can only update to accept, reject, or cancel.
      allow update: if hasRole('quotes') || 
                      (isQuoteOwner(resource.data) && (
                        isChangingStatusTo('Quote Ready') ||
                        isChangingStatusTo('Rejected') ||
                        isChangingStatusTo('Cancelled')
                      ));
      // Any authenticated, non-disabled user can create a quote request.
      allow create: if request.auth != null && isNotDisabled();
      // Users can list their own quotes; 'quotes' admins can list all quotes.
      allow list: if request.auth != null && isNotDisabled();
    }
    
    // Rules for the `orders` collection.
    match /orders/{orderId} {
      // Users can read their own orders; 'orders' admins can read any order.
      allow read: if isOwner(resource.data.userId) || hasRole('orders');
      // Only 'orders' admins can modify orders.
      allow write, update: if hasRole('orders');
      // No one can create or delete orders directly; this is handled server-side.
      allow create, delete: if false; 
      // Users can list their own orders; 'orders' admins can list all orders.
      allow list: if request.auth != null && isNotDisabled();
    }
    
    // Rules for the `purchaseOrders` collection (Admin-only).
    match /purchaseOrders/{poId} {
      // Only users with the 'purchase-orders' role have full access.
      allow read, write, create, list: if hasRole('purchase-orders');
    }
    
    // Rules for the `expenses` collection (Admin-only).
    match /expenses/{expenseId} {
      // Only users with the 'accounting' role have full access.
      allow read, write, create, list: if hasRole('accounting');
    }
    
    // Rules for the root `notifications` collection (for Admins).
    match /notifications/{notificationId} {
      // Any admin can read the list of notifications.
      allow read, list: if isAdmin();
      // Only 'notifications' admins can modify or delete admin notifications.
      allow update, delete: if hasRole('notifications');
      // Any authenticated user can create a notification (e.g., for "New User" alerts).
      allow create: if request.auth != null;
    }

    // Rules for the `settings` collection.
    match /settings/{settingId} {
      // Settings are public and can be read by anyone to display content on the site.
      allow read: if true;
      // Only users with the 'settings' role can change settings.
      allow write: if hasRole('settings');
    }
  }
}
